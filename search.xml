<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>主题2 Shell工具和脚本</title>
      <link href="/2024/03/07/%E4%B8%BB%E9%A2%982-Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/03/07/%E4%B8%BB%E9%A2%982-Shell%E5%B7%A5%E5%85%B7%E5%92%8C%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-脚本"><a href="#Shell-脚本" class="headerlink" title="Shell 脚本"></a>Shell 脚本</h1><p>到目前为止，我们已经学习了如何在 shell 中执行命令，并使用管道将命令组合使用。但是，很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流。</p><p>shell 脚本的复杂性进一步提高。</p><p>大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。shell脚本与其他脚本语言不同之处在于，shell 脚本针对 shell 所从事的相关工作进行了优化。因此，创建命令流程（pipelines）、将结果保存到文件、从标准输入中读取输入，这些都是 shell 脚本中的原生操作，这让它比通用的脚本语言更易用。本节中，我们会专注于 bash 脚本，因为它最流行，应用更为广泛。</p><p><strong>在bash中为变量赋值的语法是<code>foo=bar</code>，访问变量中存储的数值，其语法为 <code>$foo</code>。 需要注意的是，<code>foo = bar</code> （使用空格隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为参数。 总的来说，在shell脚本中使用空格会起到分割参数的作用</strong>，有时候可能会造成混淆，请务必多加检查。</p><p>Bash中的字符串通过<code>&#39;</code> 和 <code>&quot;</code>分隔符来定义，但是它们的含义并不相同。以<code>&#39;</code>定义的字符串为<strong>原义字符串</strong>，其中的变量不会被转义，而 <code>&quot;</code>定义的字符串会将变量值进行替换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo=bar</span><br><span class="line">echo &quot;$foo&quot;</span><br><span class="line"># 打印 bar</span><br><span class="line">echo &#x27;$foo&#x27;</span><br><span class="line"># 打印 $foo</span><br></pre></td></tr></table></figure><p>和其他大多数的编程语言一样，<code>bash</code>也支持<code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地， <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。下面这个函数是一个例子，它会创建一个文件夹并使用<code>cd</code>进入该文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mcd () &#123;</span><br><span class="line">    mkdir -p &quot;$1&quot;</span><br><span class="line">    cd &quot;$1&quot;</span><br><span class="line">&#125;  //-p选项表示递归创建目录，即如果上级目录不存在会一并创建</span><br></pre></td></tr></table></figure><p>这里 <strong><code>$1</code> 是脚本接收到的第一个参数</strong>。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。</p><p>步骤：</p><ol><li>将这段代码保存到一个文件中，例如<code>mcd_function.sh</code>。</li><li>使用source命令（或者<code>.</code>命令）来加载这个文件，以便将函数定义加载到当前的Shell环境中。假设文件名为<code>mcd_function.sh</code>，执行以下命令：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source mcd_function.sh</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. mcd_function.sh</span><br></pre></td></tr></table></figure><ol><li>现在您可以直接在命令行中调用<code>mcd</code>函数，并传递一个参数作为目录名。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mcd test_directory</span><br></pre></td></tr></table></figure><p>这将创建一个名为<code>test_directory</code>的目录，并将当前工作目录切换到这个新创建的目录中。</p><p>下面列举了其中一些变量，更完整的列表可以参考 <a href="https://www.tldp.org/LDP/abs/html/special-chars.html">这里</a>。</p><ul><li><p><code>$0</code> - 脚本名（举个例子，如果你有一个名为<code>myscript.sh</code>的bash脚本，里面包含以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;The name of this script is: $0&quot;</span><br></pre></td></tr></table></figure><p>当你在终端中执行<code>./myscript.sh</code>时，”$0”会被替换为<code>myscript.sh</code>，并输出”The name of this script is: <a href="http://myscript.sh/">myscript.sh</a>“。</p></li><li><p>）</p></li><li><p><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</p></li><li><p><code>$@</code> - 所有参数</p></li><li><p><code>$#</code> - 参数个数</p></li><li><p><code>$?</code> - <strong>前一个命令的返回值</strong></p></li><li><p><code>$$</code> - 当前脚本的进程识别码（PID（进程ID）在操作系统中扮演着重要的角色，它是用来唯一标识正在运行的每个进程的数字标识符。PID对于操作系统的管理和控制进程非常重要，具有以下用途：</p><ol><li>进程管理：操作系统通过PID来标识和管理每个正在运行的进程。通过PID，操作系统可以轻松地识别和跟踪每个进程的状态、资源使用情况等信息。</li><li>进程控制：通过PID，用户可以向特定的进程发送信号，控制其行为。例如，可以通过kill命令向指定PID的进程发送信号，请求终止该进程。</li><li>进程通信：在进程间通信时，PID可以用作标识符。进程可以通过PID来确定要发送消息的目标进程。</li><li>日志跟踪：在日志文件中记录进程的PID可以帮助系统管理员跟踪和诊断系统问题。</li></ol><p>总之，PID是操作系统中重要的标识符，用于唯一标识和管理每个正在运行的进程。</p></li><li><p><strong><code>!!</code> - 完整的上一条命令，包括参数。</strong>常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</p></li><li><p><strong><code>$_</code> - 上一条命令的最后一个参数。</strong>如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</p></li></ul><p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code> 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回码或退出状态是脚本&#x2F;命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</p><ul><li><code>STDOUT</code>（Standard Output）是标准输出流，用于输出命令的正常输出信息。当命令成功执行时，它会将结果输出到<code>STDOUT</code>流，这些结果通常是命令的输出值或结果。</li><li><code>STDERR</code>（Standard Error）是标准错误流，用于输出命令的错误信息或警告信息。当命令执行出错时，它会将错误信息输出到<code>STDERR</code>流，这些信息通常包括错误信息和错误码的解释。</li></ul><p>通常情况下，<code>STDOUT</code>和<code>STDERR</code>会分别显示在终端上，这样可以让用户更容易区分正常输出和错误信息。如果你想将<code>STDOUT</code>和<code>STDERR</code>输出重定向到不同的文件中，可以使用<code>&gt;</code>符号将<code>STDOUT</code>输出到一个文件中，使用<code>2&gt;</code>符号将<code>STDERR</code>输出到一个文件中，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt; output.txt 2&gt; error.txt</span><br></pre></td></tr></table></figure><p>这将命令的正常输出写入<code>output.txt</code>文件，将错误信息写入<code>error.txt</code>文件。</p><p><code>2&gt;</code>是一种重定向符号，用于将标准错误流（STDERR）输出到指定文件。在Linux和Unix系统中，每个进程都有三个标准文件描述符：标准输入（stdin，文件描述符为0）、标准输出（stdout，文件描述符为1）和标准错误（stderr，文件描述符为2）。</p><p>当使用<code>2&gt;</code>时，表示将标准错误流输出到指定的文件。</p><p>退出码可以搭配 <code>&amp;&amp;</code>（与操作符）和 <code>||</code>（或操作符）使用，用来进行条件判断，<strong>决定是否执行其他程序</strong>。它们都属于短路<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">运算符</a>（short-circuiting） <strong>同一行的多个命令可以用<code>;</code>分隔</strong>。程序 <code>true</code> 的返回码永远是<code>0</code>，<code>false</code> 的返回码永远是<code>1</code>。让我们看几个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">false || echo &quot;Oops, fail&quot;</span><br><span class="line"># Oops, fail</span><br><span class="line"></span><br><span class="line">true || echo &quot;Will not be printed&quot;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">true &amp;&amp; echo &quot;Things went well&quot;</span><br><span class="line"># Things went well</span><br><span class="line"></span><br><span class="line">false &amp;&amp; echo &quot;Will not be printed&quot;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">false ; echo &quot;This will always run&quot;</span><br><span class="line"># This will always run</span><br></pre></td></tr></table></figure><p>另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过 <em>命令替换</em>（<em>command substitution</em>）实现。</p><p>*<em>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，它的输出结果会替换掉 <code>$( CMD )</code> 。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是 <em>进程替换</em>（</em>process substitution<em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</em>*</p><p>栗子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iteration.sh脚本如下</span><br><span class="line">#!/bin/bash</span><br><span class="line">for file in $(ls)</span><br><span class="line">do</span><br><span class="line">echo &quot;Processing file is: $file&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash中运行</span><br><span class="line"> . iteration.sh &gt; files_name.txt</span><br></pre></td></tr></table></figure><p>下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用<code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;Starting program at $(date)&quot; # date会被替换成日期和时间</span><br><span class="line"></span><br><span class="line">echo &quot;Running program $0 with $# arguments with pid $$&quot;</span><br><span class="line"></span><br><span class="line">for file in &quot;$@&quot;; do</span><br><span class="line">    grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    # 如果模式没有找到，则grep退出状态为 1</span><br><span class="line">    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息</span><br><span class="line">    #windows一般丢弃到‘NUL’！！</span><br><span class="line">    if [[ $? -ne 0 ]]; then   #检查上一条命令的退出状态。如果不是 0（即未找到 &quot;foobar&quot;），则执行下面的操作。</span><br><span class="line">        echo &quot;File $file does not have any foobar, adding one&quot;</span><br><span class="line">        echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>1.在 Shell 脚本中，**”fi” 是 “if” 的反写，用于结束 if 结构**。在 if 结构中，通常使用 “if” 关键字开始条件判断，然后在满足条件时执行相应的代码块，最后使用 “fi” 关键字结束 if 结构。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [条件判断]; then</span><br><span class="line">    # 在条件满足时执行的代码</span><br><span class="line">else</span><br><span class="line">    # 在条件不满足时执行的代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>2.<code>grep</code> 是一个常用的文本搜索工具，用于在文件或标准输入中查找匹配特定模式的行，并将结果输出到标准输出。其名称来自于 <code>Global Regular Expression Print</code> 的缩写。</p><p><strong><code>grep</code> 命令的基本语法如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [options] pattern [file...]</span><br></pre></td></tr></table></figure><p><strong>其中：</strong></p><ul><li><strong><code>pattern</code> 是您要搜索的模式或正则表达式。</strong></li><li><strong><code>file</code> 是要在其中搜索匹配模式的文件。如果不指定文件，则 <code>grep</code> 将从标准输入中读取数据。</strong></li></ul><p><strong><code>grep</code> 命令的一些常用选项包括：</strong></p><ul><li><strong><code>-i</code>：忽略大小写。</strong>ignore</li><li><strong><code>-r</code>：递归搜索子目录。</strong>recursion</li><li><strong><code>-n</code>：显示匹配行的行号。</strong></li><li><strong><code>-v</code>：显示不包含匹配模式的行。</strong></li><li><strong><code>-o</code>：仅显示匹配模式的部分。</strong></li></ul><p><strong>例如，要在文件 <code>example.txt</code> 中查找包含 <code>hello</code> 的行，您可以使用以下命令：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep hello example.txt</span><br></pre></td></tr></table></figure><p><strong><code>grep</code> 是一个功能强大且灵活的工具，可用于各种文本搜索和处理任务。</strong></p><p>3.在条件语句中，我们比较 <code>$?</code> 是否等于0。**-ne意思是not equal**。 Bash实现了许多类似的比较操作，您可以查看 <a href="https://man7.org/linux/man-pages/man1/test.1.html"><code>test 手册</code></a>。 在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号 <code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容 <code>sh</code>。 更详细的说明参见<a href="http://mywiki.wooledge.org/BashFAQ/031">这里</a>。</p><p>当执行脚本时，我们经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的 <em>通配</em>（<em>globbing</em>）</p><ul><li><strong>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</strong></li><li><strong>花括号<code>&#123;&#125;</code> - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">convert image.&#123;png,jpg&#125;</span><br><span class="line"># 会展开为</span><br><span class="line">convert image.png image.jpg</span><br><span class="line"></span><br><span class="line">cp /path/to/project/&#123;foo,bar,baz&#125;.sh /newpath</span><br><span class="line"># 会展开为</span><br><span class="line">cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath</span><br><span class="line"></span><br><span class="line"># 也可以结合通配使用</span><br><span class="line">mv *&#123;.py,.sh&#125; folder</span><br><span class="line"># 会移动所有 *.py 和 *.sh 文件</span><br><span class="line"></span><br><span class="line">mkdir foo bar</span><br><span class="line"></span><br><span class="line"># 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件</span><br><span class="line">touch &#123;foo,bar&#125;/&#123;a..h&#125;</span><br><span class="line">touch foo/x bar/y</span><br><span class="line"># 比较文件夹 foo 和 bar 中包含文件的不同</span><br><span class="line">diff &lt;(ls foo) &lt;(ls bar)</span><br><span class="line"># 输出</span><br><span class="line"># &lt; x</span><br><span class="line"># ---</span><br><span class="line"># &gt; y</span><br></pre></td></tr></table></figure><p><code>convert</code> 是 ImageMagick 图像处理工具集中的一个命令，用于对图像文件进行格式转换、调整大小、合并图像、添加特效等操作。ImageMagick 是一个开源的图像处理工具集，支持多种图像格式，可以在命令行中使用。</p><p>下面是 <code>convert</code> 命令的基本语法和一些常用选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码convert input.jpg output.png</span><br></pre></td></tr></table></figure><p>这个命令将 <code>input.jpg</code> 图像文件转换为 <code>output.png</code> 图像文件。你可以使用不同的图像格式作为输入和输出。</p><p>以下是 <code>convert</code> 命令的一些常用选项：</p><ul><li><p><code>-resize</code>: 调整图像大小</p></li><li><p><code>-rotate</code>: 旋转图像</p></li><li><p><code>-crop</code>: 裁剪图像</p></li><li><p><code>-composite</code>: 合并图像</p></li><li><p><code>-blur</code>: 添加模糊效果</p></li><li><p><code>-negate</code>: 反色</p><ol><li><p><strong>调整图像大小 (-resize)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert input.jpg -resize 50% output.jpg</span><br></pre></td></tr></table></figure><p>这个命令将 <code>input.jpg</code> 图像文件调整为原来大小的50%，并保存为 <code>output.jpg</code>。</p></li><li><p><strong>旋转图像 (-rotate)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert input.jpg -rotate 90 output.jpg</span><br></pre></td></tr></table></figure><p>这个命令将 <code>input.jpg</code> 图像文件逆时针旋转90度，并保存为 <code>output.jpg</code>。</p></li><li><p><strong>裁剪图像 (-crop)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert input.jpg -crop 100x100+10+10 output.jpg</span><br></pre></td></tr></table></figure><p>这个命令将 <code>input.jpg</code> 图像文件从坐标 (10, 10) 开始裁剪大小为 100x100 的区域，并保存为 <code>output.jpg</code>。</p></li><li><p><strong>合并图像 (-composite)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert background.jpg overlay.png -composite output.jpg</span><br></pre></td></tr></table></figure><p>这个命令将 <code>overlay.png</code> 图像叠加到 <code>background.jpg</code> 图像上，并保存为 <code>output.jpg</code>。</p></li><li><p><strong>添加模糊效果 (-blur)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert input.jpg -blur 0x8 output.jpg</span><br></pre></td></tr></table></figure><p>这个命令将 <code>input.jpg</code> 图像文件添加一个水平方向模糊半径为8的模糊效果，并保存为 <code>output.jpg</code>。</p></li><li><p><strong>反色 (-negate)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert input.jpg -negate output.jpg</span><br></pre></td></tr></table></figure><p>这个命令将 <code>input.jpg</code> 图像文件进行反色处理，并保存为 <code>output.jpg</code>。</p><p>这个命令要安装imagemagick程序</p></li></ol></li></ul><p>编写 <code>bash</code> 脚本有时候会很别扭和反直觉。例如 <a href="https://github.com/koalaman/shellcheck">shellcheck</a> 这样的工具可以帮助你定位sh&#x2F;bash脚本中的错误。</p><p>注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/local/bin/python</span><br><span class="line">import sys</span><br><span class="line">for arg in reversed(sys.argv[1:]):</span><br><span class="line">    print(arg)</span><br></pre></td></tr></table></figure><p>内核知道去用 python 解释器而不是 shell 命令来运行这段脚本，是因为脚本的开头第一行的 <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>。</p><p>在 <code>shebang</code> 行中使用 <a href="https://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a> 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高了您的脚本的可移植性。<code>env</code> 会利用我们第一节讲座中介绍过的<code>PATH</code> 环境变量来进行定位。 例如，使用了<code>env</code>的shebang看上去是这样的<code>#!/usr/bin/env python</code>。</p><p>shell函数和脚本有如下一些不同点：</p><ul><li>函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li><li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li><li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li><li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li></ul><h1 id="Shell-工具"><a href="#Shell-工具" class="headerlink" title="Shell 工具"></a>Shell 工具</h1><h2 id="查看命令如何使用"><a href="#查看命令如何使用" class="headerlink" title="查看命令如何使用"></a>查看命令如何使用</h2><p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如 <code>ls -l</code>, <code>mv -i</code> 和 <code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？ 一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow 出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p><p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加<code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用<code>man</code> 命令。<a href="https://man7.org/linux/man-pages/man1/man.1.html"><code>man</code></a> 命令是手册（manual）的缩写，它提供了命令的用户手册。（<strong>windows没有man程序！！</strong>）</p><p>例如，<code>man rm</code> 会输出命令 <code>rm</code> 的说明，同时还有其标记列表，包括之前我们介绍过的<code>-i</code>。 事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p><p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。 <a href="https://tldr.sh/">TLDR pages</a> 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p><p>例如，自己就常常在tldr上搜索<a href="https://tldr.ostera.io/tar"><code>tar</code></a> 和 <a href="https://tldr.ostera.io/ffmpeg"><code>ffmpeg</code></a> 的用法。</p><h2 id="查找文件（指令太多，我决定在要找文件时直接向ChatGPT索要能达到检索目的的命令）"><a href="#查找文件（指令太多，我决定在要找文件时直接向ChatGPT索要能达到检索目的的命令）" class="headerlink" title="查找文件（指令太多，我决定在要找文件时直接向ChatGPT索要能达到检索目的的命令）"></a>查找文件（指令太多，我决定在要找文件时直接向ChatGPT索要能达到检索目的的命令）</h2><p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类UNIX系统都包含一个名为 <a href="https://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a> 的工具，它是 shell 上用于查找文件的绝佳工具。<code>find</code>命令会递归地搜索符合条件的文件，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查找所有名称为src的文件夹</span><br><span class="line">find . -name src -type d  //  .表示所有</span><br><span class="line"># 查找所有文件夹路径中包含test的python文件</span><br><span class="line">find . -path &#x27;*/test/*.py&#x27; -type f</span><br><span class="line"># 查找前一天修改的所有文件</span><br><span class="line">find . -mtime -1</span><br><span class="line"># 查找所有大小在500k至10M的tar.gz文件</span><br><span class="line">find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</span><br></pre></td></tr></table></figure><p>除了列出所寻找的文件之外，find 还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除全部扩展名为.tmp 的文件</span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"># 查找全部的 PNG 文件并将其转换为 JPG</span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure><p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name &#39;*PATTERN*&#39;</code> (如果您希望模式匹配时是不区分大小写，可以使用<code>-iname</code>选项）</p><p>您当然可以使用 alias 设置别名来简化上述操作，但 shell 的哲学之一便是寻找（更好用的）替代方案。 记住，shell 最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p><p>例如，<a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p><p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p><p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p><h2 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h2><p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p><p>为了实现这一点，很多类UNIX的系统都提供了<a href="https://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a>命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的shell工具，我们会在后续的数据清理课程中深入的探讨它。</p><p><strong><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</strong></p><p><strong>但是，我们有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</strong></p><p>因此也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查找所有使用了 requests 库的文件</span><br><span class="line">rg -t py &#x27;import requests&#x27;</span><br><span class="line"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span><br><span class="line">rg -u --files-without-match &quot;^#!&quot;</span><br><span class="line"># 查找所有的foo字符串，并打印其之后的5行</span><br><span class="line">rg foo -A 5</span><br><span class="line"># 打印匹配的统计信息（匹配的行和文件的数量）</span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure><p>与 <code>find</code>&#x2F;<code>fd</code> 一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p><p>举个栗子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -print0 | xargs -0 grep -li &#x27;STRING&#x27;</span><br></pre></td></tr></table></figure><p>这个命令的含义是：</p><ul><li><code>find . -type f -print0</code>：这部分命令使用<code>find</code>命令来查找当前目录及其子目录下的所有文件（<code>-type f</code>表示只查找文件），并使用null字符（<code>\0</code>）分隔文件名（<code>-print0</code>选项）。（<code>-print0</code>是<code>find</code>命令的一个选项，用来在输出文件名时使用null字符（<code>\0</code>）作为分隔符。）</li><li><code>|</code>：这是管道符号，用于将前一个命令的输出作为后一个命令的输入。</li><li><code>xargs -0 grep -li &#39;STRING&#39;</code>：这部分命令使用<code>xargs</code>命令来接收前一个命令（<code>find</code>）的输出，并将每个文件名作为参数传递给<code>grep</code>命令。<code>-0</code>选项表示使用null字符作为分隔符。<code>grep -li &#39;STRING&#39;</code>命令用于在每个文件中查找包含<code>STRING</code>字符串的行，且不区分大小写（<code>-i</code>选项）并打印出文件名（<code>-l</code>选项）。（<code>xargs -0</code>命令的作用是从标准输入中读取数据，并将其作为参数传递给指定的命令。其中的<code>-0</code>选项表示使用null字符（<code>\0</code>）作为参数的分隔符，这通常与<code>find</code>命令中的<code>-print0</code>选项一起使用，用于处理含有特殊字符的文件名。）</li></ul><p>综合起来，这个命令的作用是在当前目录及其子目录下的所有文件中查找包含<code>STRING</code>字符串的行，并打印出包含该字符串的文件名。</p><h2 id="查找-shell-命令"><a href="#查找-shell-命令" class="headerlink" title="查找 shell 命令"></a>查找 shell 命令</h2><p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用shell的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p><p><strong><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令</strong>。这个命令会在标准输出中打印shell中的历史命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含find子串的命令。</p><p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p><p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p><p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用的模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p><p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前的shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p><p>你可以修改 shell history 的行为，例如，<strong>如果在命令的开头加上一个空格，它就不会被加进shell记录中</strong>。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑 <code>.bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p><h2 id="文件夹导航"><a href="#文件夹导航" class="headerlink" title="文件夹导航"></a>文件夹导航</h2><p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置alias，使用 <a href="https://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p><p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用<a href="https://github.com/clvv/fasd"><code>fasd</code></a>和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p><p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em> </a>对文件和文件排序，也就是说它会同时针对频率（<em>frequency</em>）和时效（<em>recency</em>）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> missing semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主题1 the shell</title>
      <link href="/2024/03/07/%E4%B8%BB%E9%A2%981-the-shell/"/>
      <url>/2024/03/07/%E4%B8%BB%E9%A2%981-the-shell/</url>
      
        <content type="html"><![CDATA[<h2 id="shell-是什么？"><a href="#shell-是什么？" class="headerlink" title="shell 是什么？"></a>shell 是什么？</h2><p>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR&#x2F;VR 都已经无处不在。 这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。 为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</p><p>几乎所有您能够接触到的平台都支持某种形式的 shell，有些甚至还提供了多种 shell 供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p><p>本节课我们会使用 Bourne Again SHell, 简称 “bash” 。 这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开shell <em>提示符</em>（您输入指令的地方），您首先需要打开 <em>终端</em> 。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p><h2 id="使用-shell"><a href="#使用-shell" class="headerlink" title="使用 shell"></a>使用 shell</h2><p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ </span><br></pre></td></tr></table></figure><p>这是 shell 最主要的文本接口。它告诉你，你的主机名是 <code>missing</code> 并且您当前的工作目录（”current working directory”）或者说您当前所在的位置是 <code>~</code> (表示 “home”)。 <strong><code>$</code> 符号表示您现在的身份不是 root 用户（稍后会介绍）</strong>。在这个提示符中，您可以输入 <em>命令</em> ，命令最终会被 shell 解析。最简单的命令是执行一个程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ date</span><br><span class="line">Fri 10 Jan 2020 11:49:31 AM EST</span><br><span class="line">missing:~$ </span><br></pre></td></tr></table></figure><p>这里，我们执行了 <code>date</code> 这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递 <em>参数</em> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ echo hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数 <code>hello</code>。<code>echo</code> 程序将该参数打印出来。 shell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号 <code>\</code> 进行处理（<code>My\ Photos</code>）。</p><p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或 <code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询 <em>环境变量</em> <code>$PATH</code>，它会列出当 shell 接到某条指令时，进行程序搜索的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">missing:~$ which echo</span><br><span class="line">/bin/echo</span><br><span class="line">missing:~$ /bin/echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure><p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行 <code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 <code>:</code> 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是 <em>可执行程序</em>，后续课程将详细讲解）。<strong>确定某个程序名代表的是哪个具体的程序，可以使用 <code>which</code> 程序。我们也可以绕过 <code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序</strong></p><h2 id="在shell中导航"><a href="#在shell中导航" class="headerlink" title="在shell中导航"></a>在shell中导航</h2><p>shell 中的路径是一组被分割的目录，<strong>在 Linux 和 macOS 上使用 <code>/</code> 分割，而在Windows上是 <code>\</code>。路径 <code>/</code> 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在Windows上每个盘都有一个根目录（例如： <code>C:\</code>）。</strong> 我们假设您在学习本课程时使用的是 Linux 文件系统。<strong>如果某个路径以 <code>/</code> 开头，那么它是一个 <em>绝对路径</em>，其他的都是 <em>相对路径</em> 。**相对路径是指相对于当前工作目录的路径，</strong>当前工作目录可以使用 <code>pwd</code> 命令来获取。<strong>此外，切换目录需要使用 <code>cd</code> 命令。“cd -”为回到之前路径。 在路径中，</strong><code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录**：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ pwd</span><br><span class="line">/home/missing</span><br><span class="line">missing:~$ cd /home</span><br><span class="line">missing:/home$ pwd</span><br><span class="line">/home</span><br><span class="line">missing:/home$ cd ..</span><br><span class="line">missing:/$ pwd</span><br><span class="line">/</span><br><span class="line">missing:/$ cd ./home</span><br><span class="line">missing:/home$ pwd</span><br><span class="line">/home</span><br><span class="line">missing:/home$ cd missing</span><br><span class="line">missing:~$ pwd</span><br><span class="line">/home/missing</span><br><span class="line">missing:~$ ../../bin/echo hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell 提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p><p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p><p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ ls</span><br><span class="line">missing:~$ cd ..</span><br><span class="line">missing:/home$ ls</span><br><span class="line">missing</span><br><span class="line">missing:/home$ cd ..</span><br><span class="line">missing:/$ ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>除非我们利用第一个参数指定目录，否则 <code>ls</code> 会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以 <code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code> 的输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  -l                         use a long listing format</span><br><span class="line">missing:~$ ls -l /home</span><br><span class="line">drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing</span><br></pre></td></tr></table></figure><p>这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行<strong>第一个字符 <code>d</code> 表示 <code>missing</code> 是一个目录。然后接下来的九个字符，每三个字符构成一组。</strong> （<code>rwx</code>）. 它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>） 以及其他所有人具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code> 文件夹 （例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code> 目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code> 权限，也就是说任何人都可以执行这些程序。（r：read；w：write；x：execute）</p><p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如 <strong><code>mv</code>（用于重命名或移动文件）</strong>、 <strong><code>cp</code>（拷贝文件）</strong>以及 <strong><code>mkdir</code>（新建文件夹）</strong>。</p><p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试 <code>man</code> 这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用 <code>q</code> 可以退出该程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ man ls</span><br></pre></td></tr></table></figure><h5 id="如何改变权限？"><a href="#如何改变权限？" class="headerlink" title="如何改变权限？"></a>如何改变权限？</h5><p>1.使用chmod(change mode)命令,修改权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod u+r file.txt  // 给文件所有者添加读权限</span><br><span class="line">chmod g+w file.txt  // 给用户组添加写权限</span><br><span class="line">chmod o-x file.txt  // 禁止其他用户执行文件</span><br><span class="line">chmod -R u+rwx blog    //-R 选项会将我要修改的权限递归给目录中的所有文件和子目录</span><br></pre></td></tr></table></figure><p>2.右键选择“属性”-&gt;“安全”，在“安全”中修改user对文件的权限。</p><h2 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h2><p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！</p><p>**最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>**。这两个命令可以将程序的输入输出流分别重定向到文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ echo hello &gt; hello.txt</span><br><span class="line">missing:~$ cat hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$ cat &lt; hello.txt &gt; hello2.txt  //cat从hello.txt中读取内容后将内容输入到hello2.txt</span><br><span class="line">//如果hello2.txt中有内容，会被hello.txt完全覆盖！！</span><br><span class="line">missing:~$ cat hello2.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p><code>cat hello.txt</code> 和 <code>cat &lt; hello.txt</code> 这两个命令在 Linux 或 Unix 系统中都用于查看文件内容，但它们之间有一些区别。</p><ol><li><p><code>cat hello.txt</code>：这个命令会将 <code>hello.txt</code> 文件的内容输出到标准输出（通常是终端），使你可以查看文件的内容。<code>cat</code> 是 concatenate（连接）的缩写，它的主要作用是将文件内容连接在一起并输出到标准输出，通常用于显示文件内容。</p></li><li><p><code>cat &lt; hello.txt</code>：这个命令使用输入重定向 <code>&lt;</code>，将 <code>hello.txt</code> 文件的内容作为输入传递给 <code>cat</code> 命令。这样，<code>cat</code> 命令会从 <code>hello.txt</code> 文件中读取内容并将其输出到标准输出。</p></li></ol><p>主要区别在于输入来源的不同：</p><ul><li>在 <code>cat hello.txt</code> 中，<code>cat</code> 直接读取 <code>hello.txt</code> 文件的内容；</li><li>而在 <code>cat &lt; hello.txt</code> 中，<code>cat</code> 通过输入重定向符 <code>&lt;</code> 从 <code>hello.txt</code> 文件中读取内容。</li></ul><p>总体来说，这两个命令的功能都是用来显示文件内容，不同之处在于输入来源的方式不同。通常情况下，直接使用 <code>cat hello.txt</code> 就可以满足查看文件内容的需求。</p><p><strong>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容</strong>（echo “content” &gt;&gt; hello.txt）。使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。 <strong><code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ ls -l / | tail -n1</span><br><span class="line">drwxr-xr-x 1 root  root  4096 Jun 20  2019 var</span><br><span class="line">missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#x27; &#x27; -f2</span><br><span class="line">219 </span><br><span class="line">//最终输出的结果是网页内容的长度，这里是 219。</span><br></pre></td></tr></table></figure><p>这个命令的作用是通过curl命令获取google.com的响应头信息，然后使用grep命令筛选出包含”content-length”（不区分大小写）的行，接着使用cut命令以空格为分隔符提取出第2个字段（即content-length的值）。</p><p>具体解释如下：</p><ul><li><code>curl --head --silent google.com</code>：使用curl命令向google.com发出HEAD请求，只获取响应头信息，同时不显示进度信息。</li><li><code>|</code>：管道符号，将curl命令的输出作为grep命令的输入。</li><li><code>grep --ignore-case content-length</code>：在curl的输出中查找包含”content-length”（不区分大小写）的行。</li><li><code>|</code>：再次使用管道符号，将grep命令的输出作为cut命令的输入。</li><li><code>cut --delimiter=&#39; &#39; -f2</code>：以空格为分隔符，提取出第2个字段，即content-length的值。</li></ul><p>所以，该命令的输出结果是219，表示google.com的响应头中的content-length的值为219。</p><h2 id="一个功能全面又强大的工具"><a href="#一个功能全面又强大的工具" class="headerlink" title="一个功能全面又强大的工具"></a>一个功能全面又强大的工具</h2><p>对于大多数的类 Unix 系统，有一类用户是非常特殊的，那就是：根用户（root user）。 您应该已经注意到了，在上面的输出结果中，<strong>根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。</strong> 通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。 取而代之的是我们会在需要的时候<strong>使用 <code>sudo</code> 命令。顾名思义，它的作用是让您可以以 su（super user 或 root 的简写）的身份执行一些操作</strong>。 当您遇到拒绝访问（permission denied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p><p>有一件事情是您必须作为root用户才能做的，那就是向 <code>sysfs</code> 文件写入内容。系统被挂载在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。 因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。<strong>注意 Windows 和 macOS 没有这个文件</strong></p><p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code> 文件中，它位于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/class/backlight</span><br></pre></td></tr></table></figure><p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo find -L /sys/class/backlight -maxdepth 2 -name &#x27;*brightness*&#x27;</span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line">$ cd /sys/class/backlight/thinkpad_screen</span><br><span class="line">$ sudo echo 3 &gt; brightness  //在这个命令中，sudo 只应用于 echo 3 这部分命令，而 &gt; 操作符是由 shell 处理的，而不是由 sudo 处理的</span><br><span class="line">An error occurred while redirecting file &#x27;brightness&#x27;</span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure><p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了 <code>sudo</code> 命令！关于 shell，有件事我们必须要知道。**<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。** <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， <em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code> 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。</p><p>明白这一点后，我们可以这样操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo 3 | sudo tee brightness</span><br></pre></td></tr></table></figure><p><strong>因为打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。</strong> 这样您就可以在 <code>/sys</code> 中愉快地玩耍了，例如修改系统中各种LED的状态（路径可能会有所不同）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness</span><br></pre></td></tr></table></figure><p>ps: </p><ul><li><code>echo 3</code>：表示输出数字3。</li><li><code>|</code>：管道符号，将前一个命令的输出作为后一个命令的输入。</li><li><code>sudo</code>：以超级用户权限来执行后面的命令。</li><li><code>tee brightness</code>：将输入的内容同时输出到屏幕上和指定的文件brightness中。</li></ul><p>tee 是一个常用的命令行工具，用于<strong>从标准输入读取数据，并将其同时输出到标准输出</strong>（通常是终端屏幕）<strong>和一个或多个文件</strong>。tee 命令<strong>允许用户在命令行中查看输出的同时，将输出保存到文件中</strong>。</p><p>主要作用包括：</p><ol><li>从标准输入读取数据，并将数据输出到标准输出和一个或多个文件。</li><li>允许用户在命令执行过程中查看数据的同时，将数据保存到文件中，方便日后查看或分析。</li></ol><p>在使用 tee 命令时，常见的语法为：<code>command | tee file.txt</code>，这样可以将 <code>command</code> 命令的输出输出到终端并保存到 <code>file.txt</code> 文件中。</p><h1 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h1><p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//course-shell-solution">习题解答</a> 本课程中的每节课都包含一系列练习题。有些题目是有明确目的的，另外一些则是开放题，例如“尝试使用 X 和 Y”，我们强烈建议您一定要动手实践，用于尝试这些内容。 此外，我们没有为这些练习题提供答案。如果有任何困难，您可以发送邮件给我们并描述你已经做出的尝试，我们会设法帮您解答。</p><ol><li><p>本课程需要使用类Unix shell，例如 Bash 或 ZSH。如果您在 Linux 或者 MacOS 上面完成本课程的练习，则不需要做任何特殊的操作。如果您使用的是 Windows，则您不应该使用 cmd 或是 Powershell；您可以使用<a href="https://docs.microsoft.com/en-us/windows/wsl/">Windows Subsystem for Linux</a>或者是 Linux 虚拟机。使用<code>echo $SHELL</code>命令可以查看您的 shell 是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则是可以的。</p></li><li><p>在 <code>/tmp</code> 下新建一个名为 <code>missing</code> 的文件夹。</p></li><li><p>用 <code>man</code> 查看程序 <code>touch</code> 的使用手册。</p></li><li><p>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫 <code>semester</code> 的文件。</p></li><li><p>将以下内容一行一行地写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semester</span><br></pre></td></tr></table></figure><p>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">curl --head --silent https://missing.csail.mit.edu</span><br></pre></td></tr></table></figure><p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。 单引号（<code>&#39;</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting 手册</a></p></li><li><p>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 <code>ls</code> 命令来获取信息并理解其不能执行的原因。</p></li><li><p>查看 <code>chmod</code> 的手册(例如，使用 <code>man chmod</code> 命令)</p></li><li><p>使用 <code>chmod</code> 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用 <code>sh semester</code> 来执行该程序。您的 shell 是如何知晓这个文件需要使用 <code>sh</code> 来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a></p></li><li><p>使用 <code>|</code> 和 <code>&gt;</code> ，将 <code>semester</code> 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中</p></li><li><p>写一段命令来从 <code>/sys</code> 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> missing semester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的鸣谢暨我的第一篇博客！</title>
      <link href="/2024/03/07/%E6%88%91%E7%9A%84%E9%B8%A3%E8%B0%A2/"/>
      <url>/2024/03/07/%E6%88%91%E7%9A%84%E9%B8%A3%E8%B0%A2/</url>
      
        <content type="html"><![CDATA[<p>​2024年3月7日晚上10点许，对世界来说这只是一个普通的时刻，但这对我这个博客新手来说是无比奇妙的一刻！历经无数次的破防后，险些道心破碎的我终于搭建起来我人生中的第一个博客网站。管理员权限、本地仓库与git hub仓库无法同步、主题更换后网站404等等莫名其妙的问题，弄得我心力交瘁、焦头烂额，但是！所幸结果是好的：我理解了ssh秘钥的作用、拥有了我的第一个域名、对以后的学习路线有了更明确的规划。</p><p>​在我的第一篇博客下，我得感谢友人fbl对我的竭诚相助，感谢我自己不断推翻重来的耐心和我所参考过的各类推文和视频（有点官方了（⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄）)！</p><p>​此后，我将在这里更新我的学习动态，不断完善和美化我的博客网站（虽然应该没几个人看!<img src="/2024/03/07/%E6%88%91%E7%9A%84%E9%B8%A3%E8%B0%A2/0044C4BC.png" alt="0044C4BC" style="zoom: 50%;">)。</p><p>​军理课写下的第一篇博客，仓促之下，有些乱七八糟<img src="/2024/03/07/%E6%88%91%E7%9A%84%E9%B8%A3%E8%B0%A2/00469AB5.png" alt="00469AB5" style="zoom:50%;">。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
